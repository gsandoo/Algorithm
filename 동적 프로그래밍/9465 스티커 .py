# 문제
# 상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.

# 상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.



# 모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.

# 위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.

# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 

# 출력
# 각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.



# 예제 입력 1 
# 2
# 5
# 50 10 100 20 40
# 30 50 70 10 60
# 7
# 10 30 10 50 100 20 40
# 20 40 30 50 60 20 80


# 예제 출력 1 
# 260
# 290





t = int(input("테스트케이스 수"))  # 케이스 횟수 
for i in range(t):  # 반복돌리기
  s = []             # 빈 배열을 만들어준다.
  n = int(input( "열 길이"))   # 배열의 길이(인덱스 길이) 설정 해준다.
                     # [n의 길이] 라고 생각하면 된다.
  for k in range(2): #배열의 행은 2니까 2로 범위를 잡는다.
    s.append(list(map(int, input().split())))  # 배열 s 에 숫자를 입력하며 split mapping을 통해 숫자를 배열안에 삽입(append)한다.
                                               # [num,num,num,num,num...] 형식으로 형성된다.
                                               # [num,num,num,num,num...]
                                                
  for j in range(1, n):                        # 여기서 j 는 배열의 길이를 뜻한다. 1부터 하는 이유는 0은 그냥 두 수 중 큰수를 구하면 되기 때문이다. 
    if j == 1:                                 # j가 1일시 
      s[0][j] += s[1][j - 1]                   # 행이 0 , 열이 1 일시 , 1행의 j-1 열의 값을 더해준다. 
      s[1][j] += s[0][j - 1]                   # 행이 1 , 열이 1 일시 , 0 형의 j-1 열의 값을 더해준다.
    else:
      s[0][j] += max(s[1][j - 1], s[1][j - 2])  # 0행 2~n-1 열 일시 , 1행 j-1 과 1행 j-2 중에 최댓값을 더해준다.
      s[1][j] += max(s[0][j - 1], s[0][j - 2])  # 1행 2~n-1 열 일시 , 0 행 j-1 과 0행 j-2 값중 최댓값을 더해준다.
  print(max(s[0][n - 1], s[1][n - 1]))          # 0행 과 1행중 최댓값을 출력한다.